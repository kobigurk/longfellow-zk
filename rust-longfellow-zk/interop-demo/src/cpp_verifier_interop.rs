/// C++ Verifier Interoperability Module
/// 
/// This module provides FFI bindings for C++ to verify proofs generated by Rust

use longfellow_algebra::{Fp128, Field};
use longfellow_core::Result;
use longfellow_ligero::{LigeroProof, LigeroVerifier, LigeroInstance, LigeroParams, ConstraintSystem};
use longfellow_sumcheck::{SumcheckProof, SumcheckVerifier, SumcheckInstance, SumcheckOptions};
use longfellow_zk::{ZkProof, Statement, DocumentType};
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int, c_void};
use std::slice;

/// Opaque proof handle for C++
pub struct ProofHandle {
    proof: ZkProof<Fp128>,
}

/// Verification result structure for C++
#[repr(C)]
pub struct VerificationResult {
    pub valid: bool,
    pub error_message: *const c_char,
    pub ligero_valid: bool,
    pub sumcheck_valid: bool,
    pub verification_time_ms: u64,
}

/// Create a proof handle from serialized data
#[no_mangle]
pub extern "C" fn longfellow_proof_from_bytes(
    data: *const u8,
    len: usize,
) -> *mut ProofHandle {
    if data.is_null() {
        return std::ptr::null_mut();
    }
    
    let bytes = unsafe { slice::from_raw_parts(data, len) };
    
    match bincode::deserialize::<ZkProof<Fp128>>(bytes) {
        Ok(proof) => {
            let handle = Box::new(ProofHandle { proof });
            Box::into_raw(handle)
        }
        Err(_) => std::ptr::null_mut(),
    }
}

/// Create a proof handle from JSON string
#[no_mangle]
pub extern "C" fn longfellow_proof_from_json(
    json_str: *const c_char,
) -> *mut ProofHandle {
    if json_str.is_null() {
        return std::ptr::null_mut();
    }
    
    let c_str = unsafe { CStr::from_ptr(json_str) };
    let json = match c_str.to_str() {
        Ok(s) => s,
        Err(_) => return std::ptr::null_mut(),
    };
    
    match serde_json::from_str::<ZkProof<Fp128>>(json) {
        Ok(proof) => {
            let handle = Box::new(ProofHandle { proof });
            Box::into_raw(handle)
        }
        Err(_) => std::ptr::null_mut(),
    }
}

/// Verify a proof
#[no_mangle]
pub extern "C" fn longfellow_verify_proof(
    proof_handle: *const ProofHandle,
) -> VerificationResult {
    if proof_handle.is_null() {
        return VerificationResult {
            valid: false,
            error_message: CString::new("Null proof handle").unwrap().into_raw(),
            ligero_valid: false,
            sumcheck_valid: false,
            verification_time_ms: 0,
        };
    }
    
    let proof = unsafe { &(*proof_handle).proof };
    let start = std::time::Instant::now();
    
    // Verify Ligero proof
    let ligero_result = verify_ligero_component(proof);
    
    // Verify Sumcheck proof if present
    let sumcheck_result = if let Some(ref sumcheck_proof) = proof.sumcheck_proof {
        verify_sumcheck_component(sumcheck_proof, &proof.statement)
    } else {
        Ok(true)
    };
    
    let elapsed = start.elapsed();
    
    match (ligero_result, sumcheck_result) {
        (Ok(ligero_valid), Ok(sumcheck_valid)) => {
            VerificationResult {
                valid: ligero_valid && sumcheck_valid,
                error_message: std::ptr::null(),
                ligero_valid,
                sumcheck_valid,
                verification_time_ms: elapsed.as_millis() as u64,
            }
        }
        (Err(e), _) | (_, Err(e)) => {
            VerificationResult {
                valid: false,
                error_message: CString::new(e.to_string()).unwrap().into_raw(),
                ligero_valid: ligero_result.unwrap_or(false),
                sumcheck_valid: sumcheck_result.unwrap_or(false),
                verification_time_ms: elapsed.as_millis() as u64,
            }
        }
    }
}

/// Verify only the Ligero component
fn verify_ligero_component(proof: &ZkProof<Fp128>) -> Result<bool> {
    // Reconstruct constraint system from statement
    let mut cs = ConstraintSystem::new(100); // Placeholder size
    
    // Add constraints based on statement predicates
    // This is simplified - real implementation would match prover's circuit construction
    cs.add_linear_constraint(
        vec![(0, Fp128::one())],
        Fp128::zero(),
    );
    
    let params = LigeroParams::new(proof.metadata.security_bits)?;
    let instance = LigeroInstance::new(params, cs)?;
    
    let verifier = LigeroVerifier::new(instance)?;
    verifier.verify(&proof.ligero_proof)
}

/// Verify only the Sumcheck component
fn verify_sumcheck_component(
    sumcheck_proof: &SumcheckProof<Fp128>,
    statement: &Statement,
) -> Result<bool> {
    // Reconstruct sumcheck circuit from statement
    use longfellow_sumcheck::{Circuit, Layer};
    
    let mut circuit = Circuit::new();
    let input_layer = Layer::new_input(statement.revealed_fields.len());
    circuit.add_layer(input_layer);
    
    let output_layer = Layer::new(1, 0);
    circuit.add_layer(output_layer);
    circuit.finalize()?;
    
    // Create instance with dummy claimed sum
    let instance = SumcheckInstance::new(
        circuit,
        1,
        Fp128::zero(), // Would be actual sum
    )?;
    
    let verifier = SumcheckVerifier::new(instance, SumcheckOptions::default())?;
    
    // Dummy inputs for verification
    let inputs = vec![vec![Fp128::zero(); statement.revealed_fields.len()]];
    
    verifier.verify(sumcheck_proof, &inputs)
}

/// Free a proof handle
#[no_mangle]
pub extern "C" fn longfellow_proof_free(handle: *mut ProofHandle) {
    if !handle.is_null() {
        unsafe {
            Box::from_raw(handle);
        }
    }
}

/// Free an error message
#[no_mangle]
pub extern "C" fn longfellow_error_free(error: *mut c_char) {
    if !error.is_null() {
        unsafe {
            CString::from_raw(error);
        }
    }
}

/// Get proof metadata as JSON
#[no_mangle]
pub extern "C" fn longfellow_proof_metadata_json(
    proof_handle: *const ProofHandle,
) -> *mut c_char {
    if proof_handle.is_null() {
        return std::ptr::null_mut();
    }
    
    let proof = unsafe { &(*proof_handle).proof };
    
    match serde_json::to_string(&proof.metadata) {
        Ok(json) => CString::new(json).unwrap().into_raw(),
        Err(_) => std::ptr::null_mut(),
    }
}

/// Export Rust field element to C++ representation
#[repr(C)]
pub struct FieldElement {
    pub limbs: [u64; 2],
}

#[no_mangle]
pub extern "C" fn longfellow_field_from_u64(value: u64) -> FieldElement {
    let fp = Fp128::from_u64(value);
    let bytes = fp.to_bytes_le();
    
    let mut limbs = [0u64; 2];
    limbs[0] = u64::from_le_bytes(bytes[0..8].try_into().unwrap());
    if bytes.len() >= 16 {
        limbs[1] = u64::from_le_bytes(bytes[8..16].try_into().unwrap());
    }
    
    FieldElement { limbs }
}

/// Batch verification for multiple proofs
#[no_mangle]
pub extern "C" fn longfellow_batch_verify(
    proof_handles: *const *const ProofHandle,
    count: usize,
    results: *mut VerificationResult,
) -> bool {
    if proof_handles.is_null() || results.is_null() {
        return false;
    }
    
    let handles = unsafe { slice::from_raw_parts(proof_handles, count) };
    let results_slice = unsafe { slice::from_raw_parts_mut(results, count) };
    
    // Verify each proof in parallel
    use rayon::prelude::*;
    
    let verification_results: Vec<_> = handles
        .par_iter()
        .map(|&handle| {
            if handle.is_null() {
                VerificationResult {
                    valid: false,
                    error_message: CString::new("Null proof handle").unwrap().into_raw(),
                    ligero_valid: false,
                    sumcheck_valid: false,
                    verification_time_ms: 0,
                }
            } else {
                longfellow_verify_proof(handle)
            }
        })
        .collect();
    
    // Copy results
    for (i, result) in verification_results.into_iter().enumerate() {
        results_slice[i] = result;
    }
    
    true
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_field_element_export() {
        let elem = longfellow_field_from_u64(42);
        assert_eq!(elem.limbs[0], 42);
        assert_eq!(elem.limbs[1], 0);
    }
}