#include "longfellow_verifier.hpp"
#include <iostream>
#include <chrono>
#include <iomanip>

using namespace longfellow;

// Example: Verify a proof generated by Rust
int main(int argc, char* argv[]) {
    std::cout << "=== Longfellow C++ Verifier Example ===" << std::endl;
    
    // Check command line arguments
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <proof_file>" << std::endl;
        std::cerr << "  proof_file: Path to proof file (.json or .bin)" << std::endl;
        return 1;
    }
    
    std::string proof_file = argv[1];
    
    // Create verifier
    auto verifier = std::make_unique<Verifier>();
    
    // Load proof
    std::cout << "\n1. Loading proof from: " << proof_file << std::endl;
    auto load_start = std::chrono::high_resolution_clock::now();
    
    if (!verifier->load_proof_from_file(proof_file)) {
        std::cerr << "   ✗ Failed to load proof" << std::endl;
        return 1;
    }
    
    auto load_end = std::chrono::high_resolution_clock::now();
    auto load_time = std::chrono::duration_cast<std::chrono::milliseconds>(
        load_end - load_start
    ).count();
    
    std::cout << "   ✓ Proof loaded in " << load_time << " ms" << std::endl;
    
    // Get and display metadata
    std::cout << "\n2. Proof metadata:" << std::endl;
    std::string metadata = verifier->get_metadata_json();
    std::cout << metadata << std::endl;
    
    // Verify proof
    std::cout << "\n3. Verifying proof..." << std::endl;
    auto verify_start = std::chrono::high_resolution_clock::now();
    
    VerificationResult result = verifier->verify();
    
    auto verify_end = std::chrono::high_resolution_clock::now();
    auto verify_time = std::chrono::duration_cast<std::chrono::milliseconds>(
        verify_end - verify_start
    ).count();
    
    // Display results
    std::cout << "\n4. Verification results:" << std::endl;
    std::cout << "   Overall valid: " << (result.valid ? "YES" : "NO") << std::endl;
    std::cout << "   Ligero valid: " << (result.ligero_valid ? "YES" : "NO") << std::endl;
    std::cout << "   Sumcheck valid: " << (result.sumcheck_valid ? "YES" : "NO") << std::endl;
    std::cout << "   Verification time: " << result.verification_time_ms << " ms" << std::endl;
    std::cout << "   Total time (with C++): " << verify_time << " ms" << std::endl;
    
    if (result.error_message) {
        std::cout << "   Error: " << result.error_message << std::endl;
        longfellow_error_free(const_cast<char*>(result.error_message));
    }
    
    // Test field operations
    std::cout << "\n5. Testing field operations:" << std::endl;
    Fp128 a = util::field_from_u64(42);
    Fp128 b = util::field_from_u64(123);
    
    std::cout << "   Field element from 42: [" 
              << a.limbs[0] << ", " << a.limbs[1] << "]" << std::endl;
    std::cout << "   Field element from 123: [" 
              << b.limbs[0] << ", " << b.limbs[1] << "]" << std::endl;
    
    // Test utility functions
    std::cout << "\n6. Testing utility functions:" << std::endl;
    
    // SHA256
    std::string test_data = "Hello, Longfellow!";
    auto hash = util::sha256(
        reinterpret_cast<const uint8_t*>(test_data.data()),
        test_data.size()
    );
    
    std::cout << "   SHA256(\"" << test_data << "\") = ";
    for (auto byte : hash) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') 
                  << static_cast<int>(byte);
    }
    std::cout << std::dec << std::endl;
    
    // Base64
    std::string encoded = util::base64_encode(
        reinterpret_cast<const uint8_t*>(test_data.data()),
        test_data.size()
    );
    std::cout << "   Base64(\"" << test_data << "\") = " << encoded << std::endl;
    
    auto decoded = util::base64_decode(encoded);
    std::string decoded_str(decoded.begin(), decoded.end());
    std::cout << "   Decoded: \"" << decoded_str << "\"" << std::endl;
    
    // Batch verification example (if multiple files provided)
    if (argc > 2) {
        std::cout << "\n7. Batch verification of " << (argc - 1) << " proofs:" << std::endl;
        
        std::vector<std::unique_ptr<Verifier>> batch_verifiers;
        
        for (int i = 1; i < argc; i++) {
            auto v = std::make_unique<Verifier>();
            if (v->load_proof_from_file(argv[i])) {
                batch_verifiers.push_back(std::move(v));
            }
        }
        
        auto batch_start = std::chrono::high_resolution_clock::now();
        auto batch_results = Verifier::batch_verify(batch_verifiers);
        auto batch_end = std::chrono::high_resolution_clock::now();
        
        auto batch_time = std::chrono::duration_cast<std::chrono::milliseconds>(
            batch_end - batch_start
        ).count();
        
        for (size_t i = 0; i < batch_results.size(); i++) {
            std::cout << "   Proof " << (i + 1) << ": " 
                      << (batch_results[i].valid ? "VALID" : "INVALID") 
                      << " (" << batch_results[i].verification_time_ms << " ms)" 
                      << std::endl;
        }
        
        std::cout << "   Total batch time: " << batch_time << " ms" << std::endl;
    }
    
    std::cout << "\n=== Verification complete ===" << std::endl;
    
    return result.valid ? 0 : 1;
}

// Benchmark function for performance testing
void benchmark_verification(const std::string& proof_file, int iterations) {
    std::cout << "\nBenchmarking " << iterations << " iterations..." << std::endl;
    
    // Load proof once
    auto verifier = std::make_unique<Verifier>();
    if (!verifier->load_proof_from_file(proof_file)) {
        std::cerr << "Failed to load proof for benchmarking" << std::endl;
        return;
    }
    
    // Get proof bytes for repeated loading
    std::ifstream file(proof_file, std::ios::binary);
    file.seekg(0, std::ios::end);
    size_t size = file.tellg();
    file.seekg(0, std::ios::beg);
    std::vector<uint8_t> proof_data(size);
    file.read(reinterpret_cast<char*>(proof_data.data()), size);
    
    // Benchmark verification
    std::vector<double> times;
    times.reserve(iterations);
    
    for (int i = 0; i < iterations; i++) {
        auto v = std::make_unique<Verifier>();
        v->load_proof_from_bytes(proof_data.data(), proof_data.size());
        
        auto start = std::chrono::high_resolution_clock::now();
        auto result = v->verify();
        auto end = std::chrono::high_resolution_clock::now();
        
        if (!result.valid) {
            std::cerr << "Verification failed in iteration " << i << std::endl;
            break;
        }
        
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
            end - start
        ).count();
        times.push_back(duration / 1000.0); // Convert to ms
    }
    
    // Calculate statistics
    if (!times.empty()) {
        double sum = 0;
        double min_time = times[0];
        double max_time = times[0];
        
        for (double t : times) {
            sum += t;
            min_time = std::min(min_time, t);
            max_time = std::max(max_time, t);
        }
        
        double avg = sum / times.size();
        
        std::cout << "Verification time statistics (ms):" << std::endl;
        std::cout << "  Average: " << avg << std::endl;
        std::cout << "  Min: " << min_time << std::endl;
        std::cout << "  Max: " << max_time << std::endl;
    }
}